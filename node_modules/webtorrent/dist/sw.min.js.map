{"version":3,"file":"sw.min.js","mappings":"mBACA,IAAIA,GAAc,ECClBC,KAAKC,iBAAiB,UAAW,KAC/BD,KAAKE,gBAGPF,KAAKC,iBAAiB,QAASE,IAC7B,MAAMC,EDJSD,KACf,MAAM,IAAEE,GAAQF,EAAMG,QACtB,OAAKD,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,eACxCJ,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,yBAAiC,IAAIC,SAC5EL,EAAIE,SAASP,KAAKQ,aAAaC,MAAQ,sBAClC,IAAIC,SAAS,IAAIC,eAAe,CACrC,MAAAC,GACEb,GAAc,CAChB,KAQNc,gBAAsB,QAAEP,IACtB,MAAM,IAAED,EAAG,OAAES,EAAM,QAAEC,EAAO,YAAEC,GAAgBV,EACxCW,QAAmBC,QAAQC,SAAS,CAAEC,KAAM,SAAUC,qBAAqB,KAE1EC,EAAMC,SAAc,IAAIC,QAAQC,IAErC,IAAK,MAAMC,KAAUT,EAAY,CAC/B,MAAMU,EAAiB,IAAIC,gBACrB,MAAEC,EAAK,MAAEC,GAAUH,EACzBE,EAAME,UAAY,EAAGT,WACnBG,EAAQ,CAACH,EAAMO,KAEjBH,EAAOM,YAAY,CACjB3B,MACAS,SACAC,QAASkB,OAAOC,YAAYnB,EAAQoB,WACpC1B,MAAOT,KAAKQ,aAAaC,MACzBO,cACAI,KAAM,cACL,CAACU,GACN,IAGF,IAAIM,EAAU,KACd,MAAMC,EAAU,KACdd,EAAKS,aAAY,GACjBM,aAAaF,GACbb,EAAKQ,UAAY,MAGnB,MAAkB,WAAdT,EAAKiB,MACPF,IACO,IAAI3B,SAASY,EAAKiB,KAAMjB,IAG1B,IAAIZ,SAAS,IAAIC,eAAe,CACrC6B,KAAMC,GACG,IAAIjB,QAAQC,IACjBF,EAAKQ,UAAY,EAAGT,WACdA,EACFmB,EAAWC,QAAQpB,IAEnBe,IACAI,EAAWE,SAEblB,KAEG1B,IAGHuC,aAAaF,GACO,aAAhBpB,IACFoB,EAAUQ,WAAW,KACnBP,IACAZ,KAzEc,OA6EpBF,EAAKS,aAAY,KAGrB,MAAApB,GACEyB,GACF,IACEf,EACN,CAtESuB,CAAM1C,GATsD,MCEvD,CAAaA,GACrBC,GAAKD,EAAM2C,YAAY1C,KAG7BJ,KAAKC,iBAAiB,WAAY,KAChCD,KAAKkB,QAAQ6B,S","sources":["webpack://webtorrent/./lib/worker-server.js","webpack://webtorrent/./lib/worker.js"],"sourcesContent":["const portTimeoutDuration = 5000\nlet cancellable = false\n\nconst listener = event => {\n  const { url } = event.request\n  if (!url.includes(self.registration.scope + 'webtorrent/')) return null\n  if (url.includes(self.registration.scope + 'webtorrent/keepalive/')) return new Response()\n  if (url.includes(self.registration.scope + 'webtorrent/cancel/')) {\n    return new Response(new ReadableStream({\n      cancel () {\n        cancellable = true\n      }\n    }))\n  }\n  return serve(event)\n}\n\nexport default listener\n\nasync function serve ({ request }) {\n  const { url, method, headers, destination } = request\n  const clientlist = await clients.matchAll({ type: 'window', includeUncontrolled: true })\n\n  const [data, port] = await new Promise(resolve => {\n    // Use race condition for whoever controls the response stream\n    for (const client of clientlist) {\n      const messageChannel = new MessageChannel()\n      const { port1, port2 } = messageChannel\n      port1.onmessage = ({ data }) => {\n        resolve([data, port1])\n      }\n      client.postMessage({\n        url,\n        method,\n        headers: Object.fromEntries(headers.entries()),\n        scope: self.registration.scope,\n        destination,\n        type: 'webtorrent'\n      }, [port2])\n    }\n  })\n\n  let timeOut = null\n  const cleanup = () => {\n    port.postMessage(false) // send a cancel request\n    clearTimeout(timeOut)\n    port.onmessage = null\n  }\n\n  if (data.body !== 'STREAM') {\n    cleanup()\n    return new Response(data.body, data)\n  }\n\n  return new Response(new ReadableStream({\n    pull (controller) {\n      return new Promise(resolve => {\n        port.onmessage = ({ data }) => {\n          if (data) {\n            controller.enqueue(data) // data is Uint8Array\n          } else {\n            cleanup()\n            controller.close() // data is null, means the stream ended\n          }\n          resolve()\n        }\n        if (!cancellable) {\n          // firefox doesn't support cancelling of Readable Streams in service workers,\n          // so we just empty it after 5s of inactivity, the browser will request another port anyways\n          clearTimeout(timeOut)\n          if (destination !== 'document') {\n            timeOut = setTimeout(() => {\n              cleanup()\n              resolve()\n            }, portTimeoutDuration)\n          }\n        }\n        port.postMessage(true) // send a pull request\n      })\n    },\n    cancel () {\n      cleanup()\n    }\n  }), data)\n}\n","import fileResponse from './worker-server.js'\n\nself.addEventListener('install', () => {\n  self.skipWaiting()\n})\n\nself.addEventListener('fetch', event => {\n  const res = fileResponse(event)\n  if (res) event.respondWith(res)\n})\n\nself.addEventListener('activate', () => {\n  self.clients.claim()\n})\n"],"names":["cancellable","self","addEventListener","skipWaiting","event","res","url","request","includes","registration","scope","Response","ReadableStream","cancel","async","method","headers","destination","clientlist","clients","matchAll","type","includeUncontrolled","data","port","Promise","resolve","client","messageChannel","MessageChannel","port1","port2","onmessage","postMessage","Object","fromEntries","entries","timeOut","cleanup","clearTimeout","body","pull","controller","enqueue","close","setTimeout","serve","respondWith","claim"],"sourceRoot":""}