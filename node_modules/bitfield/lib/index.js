"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
/**
 * Converts a number of bits to a number of bytes.
 *
 * @param numberOfBits The number of bits to convert.
 * @returns The number of bytes that are needed to store the given number of bits.
 */
function bitsToBytes(numberOfBits) {
    return (numberOfBits >> 3) + Number(numberOfBits % 8 !== 0);
}
var BitField = /** @class */ (function () {
    /**
     * Constructs a BitField.
     *
     * @param data Either a number representing the maximum number of supported bits, or a Uint8Array.
     * @param opts Options for the bitfield.
     */
    function BitField(data, options) {
        if (data === void 0) { data = 0; }
        var grow = options === null || options === void 0 ? void 0 : options.grow;
        this.grow = grow
            ? Number.isFinite(grow)
                ? bitsToBytes(grow)
                : grow
            : 0;
        this.buffer =
            typeof data === "number" ? new Uint8Array(bitsToBytes(data)) : data;
    }
    Object.defineProperty(BitField.prototype, "length", {
        /** The number of bits in the bitfield. */
        get: function () {
            return this.buffer.length << 3;
        },
        enumerable: false,
        configurable: true
    });
    /**
     * Get a particular bit.
     *
     * @param bitIndex Bit index to retrieve.
     * @returns A boolean indicating whether the `i`th bit is set.
     */
    BitField.prototype.get = function (bitIndex) {
        var byteIndex = bitIndex >> 3;
        return (byteIndex < this.buffer.length &&
            !!(this.buffer[byteIndex] & (128 >> bitIndex % 8)));
    };
    /**
     * Set a particular bit.
     *
     * Will grow the underlying array if the bit is out of bounds and the `grow` option is set.
     *
     * @param bitIndex Bit index to set.
     * @param value Value to set the bit to. Defaults to `true`.
     */
    BitField.prototype.set = function (bitIndex, value) {
        if (value === void 0) { value = true; }
        var byteIndex = bitIndex >> 3;
        if (value) {
            if (byteIndex >= this.buffer.length) {
                var newLength = Math.max(byteIndex + 1, Math.min(2 * this.buffer.length, this.grow));
                if (newLength <= this.grow) {
                    var newBuffer = new Uint8Array(newLength);
                    newBuffer.set(this.buffer);
                    this.buffer = newBuffer;
                }
            }
            this.buffer[byteIndex] |= 128 >> bitIndex % 8;
        }
        else if (byteIndex < this.buffer.length) {
            this.buffer[byteIndex] &= ~(128 >> bitIndex % 8);
        }
    };
    /**
     * Sets a value or an array of values.
     *
     * @param array An array of booleans to set.
     * @param offset The bit offset at which the values are to be written.
     */
    BitField.prototype.setAll = function (array, offset) {
        if (offset === void 0) { offset = 0; }
        var targetLength = Math.min(bitsToBytes(offset + array.length), this.grow);
        if (this.buffer.length < targetLength) {
            var newBuffer = new Uint8Array(targetLength);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
        }
        var byteIndex = offset >> 3;
        var bitMask = 128 >> offset % 8;
        for (var index = 0; index < array.length; index++) {
            if (array[index]) {
                this.buffer[byteIndex] |= bitMask;
            }
            else {
                this.buffer[byteIndex] &= ~bitMask;
            }
            if (bitMask === 1) {
                byteIndex += 1;
                if (byteIndex >= this.buffer.length) {
                    break;
                }
                bitMask = 128;
            }
            else {
                bitMask >>= 1;
            }
        }
    };
    /**
     * Loop through the bits in the bitfield.
     *
     * @param callbackfn Function to be called with the bit value and index.
     * @param start Index of the first bit to look at.
     * @param end Index of the first bit that should no longer be considered.
     */
    BitField.prototype.forEach = function (callbackfn, start, end) {
        if (start === void 0) { start = 0; }
        if (end === void 0) { end = this.buffer.length * 8; }
        var byteIndex = start >> 3;
        var bitMask = 128 >> start % 8;
        for (var bitIndex = start; bitIndex < end; bitIndex++) {
            callbackfn(!!(this.buffer[byteIndex] & bitMask), bitIndex);
            if (bitMask === 1) {
                byteIndex += 1;
                bitMask = 128;
            }
            else {
                bitMask >>= 1;
            }
        }
    };
    /**
     * Check if all bits in the Bitfield are unset.
     *
     * @returns A boolean indicating whether all bits are unset.
     */
    BitField.prototype.isEmpty = function () {
        for (var i = 0; i < this.buffer.length; i++) {
            if (this.buffer[i] !== 0) {
                return false;
            }
        }
        return true;
    };
    return BitField;
}());
exports.default = BitField;
//# sourceMappingURL=index.js.map