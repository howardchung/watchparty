/**
 * Converts a number of bits to a number of bytes.
 *
 * @param numberOfBits The number of bits to convert.
 * @returns The number of bytes that are needed to store the given number of bits.
 */
function bitsToBytes(numberOfBits) {
    return (numberOfBits >> 3) + Number(numberOfBits % 8 !== 0);
}
export default class BitField {
    /** The number of bits in the bitfield. */
    get length() {
        return this.buffer.length << 3;
    }
    /**
     * Constructs a BitField.
     *
     * @param data Either a number representing the maximum number of supported bits, or a Uint8Array.
     * @param opts Options for the bitfield.
     */
    constructor(data = 0, options) {
        const grow = options === null || options === void 0 ? void 0 : options.grow;
        this.grow = grow
            ? Number.isFinite(grow)
                ? bitsToBytes(grow)
                : grow
            : 0;
        this.buffer =
            typeof data === "number" ? new Uint8Array(bitsToBytes(data)) : data;
    }
    /**
     * Get a particular bit.
     *
     * @param bitIndex Bit index to retrieve.
     * @returns A boolean indicating whether the `i`th bit is set.
     */
    get(bitIndex) {
        const byteIndex = bitIndex >> 3;
        return (byteIndex < this.buffer.length &&
            !!(this.buffer[byteIndex] & (128 >> bitIndex % 8)));
    }
    /**
     * Set a particular bit.
     *
     * Will grow the underlying array if the bit is out of bounds and the `grow` option is set.
     *
     * @param bitIndex Bit index to set.
     * @param value Value to set the bit to. Defaults to `true`.
     */
    set(bitIndex, value = true) {
        const byteIndex = bitIndex >> 3;
        if (value) {
            if (byteIndex >= this.buffer.length) {
                const newLength = Math.max(byteIndex + 1, Math.min(2 * this.buffer.length, this.grow));
                if (newLength <= this.grow) {
                    const newBuffer = new Uint8Array(newLength);
                    newBuffer.set(this.buffer);
                    this.buffer = newBuffer;
                }
            }
            this.buffer[byteIndex] |= 128 >> bitIndex % 8;
        }
        else if (byteIndex < this.buffer.length) {
            this.buffer[byteIndex] &= ~(128 >> bitIndex % 8);
        }
    }
    /**
     * Sets a value or an array of values.
     *
     * @param array An array of booleans to set.
     * @param offset The bit offset at which the values are to be written.
     */
    setAll(array, offset = 0) {
        const targetLength = Math.min(bitsToBytes(offset + array.length), this.grow);
        if (this.buffer.length < targetLength) {
            const newBuffer = new Uint8Array(targetLength);
            newBuffer.set(this.buffer);
            this.buffer = newBuffer;
        }
        let byteIndex = offset >> 3;
        let bitMask = 128 >> offset % 8;
        for (let index = 0; index < array.length; index++) {
            if (array[index]) {
                this.buffer[byteIndex] |= bitMask;
            }
            else {
                this.buffer[byteIndex] &= ~bitMask;
            }
            if (bitMask === 1) {
                byteIndex += 1;
                if (byteIndex >= this.buffer.length) {
                    break;
                }
                bitMask = 128;
            }
            else {
                bitMask >>= 1;
            }
        }
    }
    /**
     * Loop through the bits in the bitfield.
     *
     * @param callbackfn Function to be called with the bit value and index.
     * @param start Index of the first bit to look at.
     * @param end Index of the first bit that should no longer be considered.
     */
    forEach(callbackfn, start = 0, end = this.buffer.length * 8) {
        let byteIndex = start >> 3;
        let bitMask = 128 >> start % 8;
        for (let bitIndex = start; bitIndex < end; bitIndex++) {
            callbackfn(!!(this.buffer[byteIndex] & bitMask), bitIndex);
            if (bitMask === 1) {
                byteIndex += 1;
                bitMask = 128;
            }
            else {
                bitMask >>= 1;
            }
        }
    }
    /**
     * Check if all bits in the Bitfield are unset.
     *
     * @returns A boolean indicating whether all bits are unset.
     */
    isEmpty() {
        for (let i = 0; i < this.buffer.length; i++) {
            if (this.buffer[i] !== 0) {
                return false;
            }
        }
        return true;
    }
}
//# sourceMappingURL=index.js.map