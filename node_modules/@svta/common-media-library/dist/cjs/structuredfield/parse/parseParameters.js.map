{"version":3,"file":"parseParameters.js","sourceRoot":"","sources":["../../../../src/structuredfield/parse/parseParameters.ts"],"names":[],"mappings":";;AA6CA,0CA6BC;AAvED,qDAA+C;AAC/C,yDAAmD;AACnD,+CAAyC;AAEzC,+BAA+B;AAC/B,EAAE;AACF,qEAAqE;AACrE,uEAAuE;AACvE,SAAS;AACT,EAAE;AACF,+CAA+C;AAC/C,EAAE;AACF,uCAAuC;AACvC,EAAE;AACF,sEAAsE;AACtE,gBAAgB;AAChB,EAAE;AACF,sEAAsE;AACtE,EAAE;AACF,+DAA+D;AAC/D,EAAE;AACF,gEAAgE;AAChE,+CAA+C;AAC/C,EAAE;AACF,2CAA2C;AAC3C,EAAE;AACF,yDAAyD;AACzD,EAAE;AACF,4DAA4D;AAC5D,4BAA4B;AAC5B,EAAE;AACF,sEAAsE;AACtE,wDAAwD;AACxD,EAAE;AACF,sEAAsE;AACtE,sEAAsE;AACtE,yDAAyD;AACzD,EAAE;AACF,yBAAyB;AACzB,EAAE;AACF,wEAAwE;AACxE,gDAAgD;AAChD,SAAgB,eAAe,CAAC,GAAW,EAAE,OAAyB;IACrE,IAAI,UAAU,GAA6B,SAAS,CAAC;IACrD,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACvB,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACpB,MAAM;QACP,CAAC;QAED,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAC9B,MAAM,SAAS,GAAG,IAAA,sBAAQ,EAAC,GAAG,CAAC,CAAC;QAChC,MAAM,GAAG,GAAG,SAAS,CAAC,KAAK,CAAC;QAC5B,IAAI,KAAK,GAAG,IAAI,CAAC;QACjB,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC;QAEpB,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACpB,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;YACvB,MAAM,cAAc,GAAG,IAAA,gCAAa,EAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACnD,KAAK,GAAG,cAAc,CAAC,KAAY,CAAC;YACpC,GAAG,GAAG,cAAc,CAAC,GAAG,CAAC;QAC1B,CAAC;QAED,0CAA0C;QAC1C,IAAI,UAAU,IAAI,IAAI,EAAE,CAAC;YACxB,UAAU,GAAG,EAAE,CAAC;QACjB,CAAC;QAED,gCAAgC;QAChC,UAAU,CAAC,GAAG,CAAC,GAAG,KAAK,CAAC;IACzB,CAAC;IACD,OAAO,IAAA,4BAAW,EAAC,UAAU,EAAE,GAAG,CAAC,CAAC;AACrC,CAAC","sourcesContent":["import type { SfDecodeOptions } from '../SfDecodeOptions.js';\nimport type { SfParameters } from '../SfParameters.js';\nimport type { ParsedValue } from './ParsedValue.js';\nimport { parsedValue } from './ParsedValue.js';\nimport { parseBareItem } from './parseBareItem.js';\nimport { parseKey } from './parseKey.js';\n\n// 4.2.3.2.  Parsing Parameters\n//\n// Given an ASCII string as input_string, return an ordered map whose\n// values are bare Items. input_string is modified to remove the parsed\n// value.\n//\n// 1.  Let parameters be an empty, ordered map.\n//\n// 2.  While input_string is not empty:\n//\n//     1.  If the first character of input_string is not \";\", exit the\n//         loop.\n//\n//     2.  Consume a \";\" character from the beginning of input_string.\n//\n//     3.  Discard any leading SP characters from input_string.\n//\n//     4.  let param_name be the result of running Parsing a Key\n//         (Section 4.2.3.3) with input_string.\n//\n//     5.  Let param_value be Boolean true.\n//\n//     6.  If the first character of input_string is \"=\":\n//\n//         1.  Consume the \"=\" character at the beginning of\n//             input_string.\n//\n//         2.  Let param_value be the result of running Parsing a Bare\n//             Item (Section 4.2.3.1) with input_string.\n//\n//     7.  Append key param_name with value param_value to parameters.\n//         If parameters already contains a name param_name (comparing\n//         character-for-character), overwrite its value.\n//\n// 3.  Return parameters.\n//\n// Note that when duplicate Parameter keys are encountered, this has the\n// effect of ignoring all but the last instance.\nexport function parseParameters(src: string, options?: SfDecodeOptions): ParsedValue<SfParameters | undefined> {\n\tlet parameters: SfParameters | undefined = undefined;\n\twhile (src.length > 0) {\n\t\tif (src[0] !== ';') {\n\t\t\tbreak;\n\t\t}\n\n\t\tsrc = src.substring(1).trim();\n\t\tconst parsedKey = parseKey(src);\n\t\tconst key = parsedKey.value;\n\t\tlet value = true;\n\t\tsrc = parsedKey.src;\n\n\t\tif (src[0] === '=') {\n\t\t\tsrc = src.substring(1);\n\t\t\tconst parsedBareItem = parseBareItem(src, options);\n\t\t\tvalue = parsedBareItem.value as any;\n\t\t\tsrc = parsedBareItem.src;\n\t\t}\n\n\t\t// initialize as object when params exists\n\t\tif (parameters == null) {\n\t\t\tparameters = {};\n\t\t}\n\n\t\t// override if param_name exists\n\t\tparameters[key] = value;\n\t}\n\treturn parsedValue(parameters, src);\n}\n"]}