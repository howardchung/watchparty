{"version":3,"file":"serializeByteSequence.js","sourceRoot":"","sources":["../../../../src/structuredfield/serialize/serializeByteSequence.ts"],"names":[],"mappings":";;AA4BA,sDAKC;AAjCD,iEAA2D;AAC3D,gDAA0C;AAC1C,2DAAqD;AAErD,sCAAsC;AACtC,EAAE;AACF,wEAAwE;AACxE,iCAAiC;AACjC,EAAE;AACF,qEAAqE;AACrE,EAAE;AACF,qCAAqC;AACrC,EAAE;AACF,4BAA4B;AAC5B,EAAE;AACF,8DAA8D;AAC9D,sEAAsE;AACtE,EAAE;AACF,4BAA4B;AAC5B,EAAE;AACF,qBAAqB;AACrB,EAAE;AACF,wEAAwE;AACxE,eAAe;AACf,EAAE;AACF,kEAAkE;AAClE,oEAAoE;AACpE,8BAA8B;AAC9B,SAAgB,qBAAqB,CAAC,KAAiB;IACtD,IAAI,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,CAAC;QACzC,MAAM,IAAA,kCAAc,EAAC,KAAK,EAAE,gBAAK,CAAC,CAAC;IACpC,CAAC;IACD,OAAO,IAAI,IAAA,8BAAY,EAAC,KAAK,CAAC,GAAG,CAAC;AACnC,CAAC","sourcesContent":["import { encodeBase64 } from '../../utils/encodeBase64.js';\nimport { BYTES } from '../utils/BYTES.js';\nimport { serializeError } from './serializeError.js';\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nexport function serializeByteSequence(value: Uint8Array) {\n\tif (ArrayBuffer.isView(value) === false) {\n\t\tthrow serializeError(value, BYTES);\n\t}\n\treturn `:${encodeBase64(value)}:`;\n}\n"]}