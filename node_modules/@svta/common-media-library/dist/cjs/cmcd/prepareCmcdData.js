"use strict";
Object.defineProperty(exports, "__esModule", { value: true });
exports.prepareCmcdData = prepareCmcdData;
const isTokenField_js_1 = require("../cta/utils/isTokenField.js");
const isValid_js_1 = require("../cta/utils/isValid.js");
const SfToken_js_1 = require("../structuredfield/SfToken.js");
const CMCD_EVENT_MODE_js_1 = require("./CMCD_EVENT_MODE.js");
const CMCD_FORMATTER_MAP_js_1 = require("./CMCD_FORMATTER_MAP.js");
const CMCD_REQUEST_MODE_js_1 = require("./CMCD_REQUEST_MODE.js");
const CMCD_RESPONSE_MODE_js_1 = require("./CMCD_RESPONSE_MODE.js");
const isCmcdEventKey_js_1 = require("./isCmcdEventKey.js");
const isCmcdRequestKey_js_1 = require("./isCmcdRequestKey.js");
const isCmcdResponseKey_js_1 = require("./isCmcdResponseKey.js");
const isCmcdV1Key_js_1 = require("./isCmcdV1Key.js");
const filterMap = {
    [CMCD_RESPONSE_MODE_js_1.CMCD_RESPONSE_MODE]: isCmcdResponseKey_js_1.isCmcdResponseKey,
    [CMCD_EVENT_MODE_js_1.CMCD_EVENT_MODE]: isCmcdEventKey_js_1.isCmcdEventKey,
    [CMCD_REQUEST_MODE_js_1.CMCD_REQUEST_MODE]: isCmcdRequestKey_js_1.isCmcdRequestKey,
};
/**
 * Convert a generic object to CMCD data.
 *
 * @param obj - The CMCD object to process.
 * @param options - Options for encoding.
 *
 * @group CMCD
 *
 * @beta
 */
function prepareCmcdData(obj, options = {}) {
    const results = {};
    if (obj == null || typeof obj !== 'object') {
        return results;
    }
    const version = options.version || obj['v'] || 1;
    const reportingMode = options.reportingMode || CMCD_REQUEST_MODE_js_1.CMCD_REQUEST_MODE;
    const keyFilter = version === 1 ? isCmcdV1Key_js_1.isCmcdV1Key : filterMap[reportingMode];
    // Filter keys based on the version, reporting mode and options
    let keys = Object.keys(obj).filter(keyFilter);
    const filter = options.filter;
    if (typeof filter === 'function') {
        keys = keys.filter(filter);
    }
    // Ensure all required keys are present before sorting
    const needsTimestamp = reportingMode === CMCD_RESPONSE_MODE_js_1.CMCD_RESPONSE_MODE || reportingMode === CMCD_EVENT_MODE_js_1.CMCD_EVENT_MODE;
    if (needsTimestamp && !keys.includes('ts')) {
        keys.push('ts');
    }
    if (version > 1 && !keys.includes('v')) {
        keys.push('v');
    }
    const formatters = Object.assign({}, CMCD_FORMATTER_MAP_js_1.CMCD_FORMATTER_MAP, options.formatters);
    const formatterOptions = {
        version,
        reportingMode,
        baseUrl: options.baseUrl,
    };
    keys.sort().forEach(key => {
        let value = obj[key];
        const formatter = formatters[key];
        if (typeof formatter === 'function') {
            value = formatter(value, formatterOptions);
        }
        // Version should only be reported if not equal to 1.
        if (key === 'v') {
            if (version === 1) {
                return;
            }
            else {
                value = version;
            }
        }
        // Playback rate should only be sent if not equal to 1.
        if (key == 'pr' && value === 1) {
            return;
        }
        // Ensure a timestamp is set for response and event modes
        if (needsTimestamp && key === 'ts' && !Number.isFinite(value)) {
            value = Date.now();
        }
        // ignore invalid values
        if (!(0, isValid_js_1.isValid)(value)) {
            return;
        }
        if ((0, isTokenField_js_1.isTokenField)(key) && typeof value === 'string') {
            value = new SfToken_js_1.SfToken(value);
        }
        results[key] = value;
    });
    return results;
}
//# sourceMappingURL=prepareCmcdData.js.map