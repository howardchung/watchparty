{"version":3,"file":"trackToSegmentBase.js","sourceRoot":"","sources":["../../../../../../../src/cmaf/ham/mapper/dash/mapHamToDash/trackToSegmentBase.ts"],"names":[],"mappings":";;AAOA,gDA4DC;AA5DD,SAAgB,kBAAkB,CAAC,KAAY;;IAC9C,MAAM,QAAQ,GAAkB,EAAE,CAAC;IACnC,IACC,KAAK,CAAC,QAAQ,CAAC,MAAM,GAAG,CAAC;QACzB,KAAK,CAAC,SAAS;QACf,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS;QAC3B,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC,EACxC,CAAC;QACF,IAAI,YAAY,GAA4B,SAAS,CAAC;QACtD,MAAM,aAAa,GAAG,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC;YAClD,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC/B,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC;gBAC9B,CAAC,CAAC,KAAK,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC/B,CAAC,CAAC,EAAE,CAAC;QACP,MAAM,SAAS,GAAW,CAAC,aAAa,GAAG,CAAC,CAAC;QAC7C,MAAM,gBAAgB,GAAG,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC;YACjE,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;YAC3C,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,QAAQ,CAAC,GAAG,CAAC;gBAC1C,CAAC,CAAC,KAAK,CAAC,QAAQ,CAAC,CAAC,CAAC,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC;gBAC3C,CAAC,CAAC,EAAE,CAAC;QACP,MAAM,oBAAoB,GAAW,CAAC,gBAAgB,GAAG,CAAC,CAAC;QAC3D,YAAY,GAAG;YACd,CAAC,EAAE;gBACF,UAAU,EAAE,GAAG,aAAa,IAAI,oBAAoB,EAAE;aACtD;YACD,cAAc,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,SAAS,EAAE,EAAE,EAAE,CAAC;SACrC,CAAC;QACjB,IAAI,YAAY,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;YAC5C,wFAAwF;YACxF,MAAM,UAAU,GAAG,KAAmB,CAAC;YACvC,YAAY,CAAC,CAAC,CAAC,SAAS,GAAG,MAAA,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,mCAAI,EAAE,CAAC;QACnE,CAAC;QACD,IAAI,YAAY,EAAE,CAAC;YAClB,QAAQ,CAAC,IAAI,CAAC,YAAY,CAAC,CAAC;QAC7B,CAAC;IACF,CAAC;SACI,CAAC;QACL,KAAK,CAAC,QAAQ,CAAC,OAAO,CAAC,CAAC,OAAgB,EAAE,EAAE;;YAC3C,IAAI,UAAmC,CAAC;YACxC,IAAI,OAAO,CAAC,SAAS,EAAE,CAAC;gBACvB,MAAM,SAAS,GAAW,CAAC,OAAO,CAAC,SAAS,CAAC,KAAK,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,GAAG,CAAC,CAAC;gBAC/D,UAAU,GAAG;oBACZ,CAAC,EAAE;wBACF,UAAU,EAAE,OAAO,CAAC,SAAS;qBAC7B;oBACD,cAAc,EAAE,CAAC,EAAE,CAAC,EAAE,EAAE,KAAK,EAAE,KAAK,SAAS,EAAE,EAAE,EAAE,CAAC;iBACrC,CAAC;YAClB,CAAC;YACD,IAAI,UAAU,IAAI,KAAK,CAAC,IAAI,KAAK,OAAO,EAAE,CAAC;gBAC1C,wFAAwF;gBACxF,MAAM,UAAU,GAAG,KAAmB,CAAC;gBACvC,UAAU,CAAC,CAAC,CAAC,SAAS,GAAG,MAAA,UAAU,CAAC,UAAU,CAAC,QAAQ,EAAE,mCAAI,EAAE,CAAC;YACjE,CAAC;YACD,IAAI,UAAU,EAAE,CAAC;gBAChB,QAAQ,CAAC,IAAI,CAAC,UAAU,CAAC,CAAC;YAC3B,CAAC;QACF,CAAC,CAAC,CAAC;IACJ,CAAC;IAED,OAAO,QAAQ,CAAC;AACjB,CAAC","sourcesContent":["\nimport type { AudioTrack } from '../../../types/model/AudioTrack.js';\nimport type { Segment } from '../../../types/model/Segment.js';\nimport type { Track } from '../../../types/model/Track.js';\n\nimport type { SegmentBase } from '../../../types/mapper/dash/SegmentBase.js';\n\nexport function trackToSegmentBase(track: Track): SegmentBase[] {\n\tconst segments: SegmentBase[] = [];\n\tif (\n\t\ttrack.segments.length > 0 &&\n\t\ttrack.byteRange &&\n\t\ttrack.segments[0].byteRange &&\n\t\ttrack.segments[0].byteRange.includes('@')\n\t) {\n\t\tlet firstSegment: SegmentBase | undefined = undefined;\n\t\tconst initByteRange = track.byteRange.includes('-')\n\t\t\t? track.byteRange.split('-')[1]\n\t\t\t: track.byteRange.includes('@')\n\t\t\t\t? track.byteRange.split('@')[0]\n\t\t\t\t: '';\n\t\tconst initRange: number = +initByteRange - 1;\n\t\tconst byteFirstSegment = track.segments[0].byteRange.includes('-')\n\t\t\t? track.segments[0].byteRange.split('-')[1]\n\t\t\t: track.segments[0].byteRange.includes('@')\n\t\t\t\t? track.segments[0].byteRange.split('@')[1]\n\t\t\t\t: '';\n\t\tconst numberFirstByteRange: number = +byteFirstSegment - 1;\n\t\tfirstSegment = {\n\t\t\t$: {\n\t\t\t\tindexRange: `${initByteRange}-${numberFirstByteRange}`,\n\t\t\t},\n\t\t\tInitialization: [{ $: { range: `0-${initRange}` } }],\n\t\t} as SegmentBase;\n\t\tif (firstSegment && track.type === 'audio') {\n\t\t\t// All segments should have timescale, but for now, just the audio ones store this value\n\t\t\tconst audioTrack = track as AudioTrack;\n\t\t\tfirstSegment.$.timescale = audioTrack.sampleRate.toString() ?? '';\n\t\t}\n\t\tif (firstSegment) {\n\t\t\tsegments.push(firstSegment);\n\t\t}\n\t}\n\telse {\n\t\ttrack.segments.forEach((segment: Segment) => {\n\t\t\tlet newSegment: SegmentBase | undefined;\n\t\t\tif (segment.byteRange) {\n\t\t\t\tconst initRange: number = +segment.byteRange.split('-')[0] - 1;\n\t\t\t\tnewSegment = {\n\t\t\t\t\t$: {\n\t\t\t\t\t\tindexRange: segment.byteRange,\n\t\t\t\t\t},\n\t\t\t\t\tInitialization: [{ $: { range: `0-${initRange}` } }],\n\t\t\t\t} as SegmentBase;\n\t\t\t}\n\t\t\tif (newSegment && track.type === 'audio') {\n\t\t\t\t// All segments should have timescale, but for now, just the audio ones store this value\n\t\t\t\tconst audioTrack = track as AudioTrack;\n\t\t\t\tnewSegment.$.timescale = audioTrack.sampleRate.toString() ?? '';\n\t\t\t}\n\t\t\tif (newSegment) {\n\t\t\t\tsegments.push(newSegment);\n\t\t\t}\n\t\t});\n\t}\n\n\treturn segments;\n}\n"]}