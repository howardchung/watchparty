{"version":3,"file":"audioGroupsToSwitchingSets.js","sourceRoot":"","sources":["../../../../../../../src/cmaf/ham/mapper/hls/mapHlsToHam/audioGroupsToSwitchingSets.ts"],"names":[],"mappings":";;AAyBA,gEA4CC;AAhED,gFAA0E;AAE1E,iEAA2D;AAC3D,6DAAuD;AACvD,qDAA+C;AAC/C,2DAAqD;AAErD;;;;;;;;;;;;GAYG;AACH,SAAgB,0BAA0B,CACzC,gBAAqB,EACrB,iBAA6B;;IAE7B,MAAM,kBAAkB,GAAmB,EAAE,CAAC;IAC9C,MAAM,WAAW,GAAiB,EAAE,CAAC;IAErC,KAAK,MAAM,cAAc,IAAI,gBAAgB,EAAE,CAAC;QAC/C,MAAM,SAAS,GAAG,gBAAgB,CAAC,cAAc,CAAC,CAAC;QACnD,KAAK,MAAM,KAAK,IAAI,SAAS,EAAE,CAAC;YAC/B,MAAM,UAAU,GAAQ,SAAS,CAAC,KAAK,CAAC,CAAC;YACzC,MAAM,EAAE,QAAQ,EAAE,GAAG,EAAE,GAAG,UAAU,CAAC;YACrC,MAAM,WAAW,GAAG,IAAA,sCAAgB,EACnC,MAAA,iBAAiB,CAAC,KAAK,EAAE,0CAAE,QAAQ,CACnC,CAAC;YACF,MAAM,GAAG,GAAG,MAAA,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,QAAQ,CAAC,CAAC,CAAC,0CAAE,GAAG,CAAC;YAC1C,MAAM,QAAQ,GAAG,IAAA,kCAAc,EAAC,WAAW,aAAX,WAAW,uBAAX,WAAW,CAAE,QAAQ,CAAC,CAAC;YAEvD,4DAA4D;YAC5D,4EAA4E;YAC5E,MAAM,SAAS,GAAG,IAAA,8BAAY,EAAC,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,SAAS,CAAC,CAAC;YAC/C,WAAW,CAAC,IAAI,CAAC;gBAChB,EAAE,EAAE,KAAK;gBACT,IAAI,EAAE,OAAO;gBACb,QAAQ,EAAE,GAAG;gBACb,KAAK,EAAE,IAAA,sBAAQ,EAAC,OAAO,CAAC;gBACxB,QAAQ,EAAE,IAAA,4BAAW,EAAC,WAAW,EAAE,QAAQ,CAAC;gBAC5C,QAAQ,EAAE,QAAQ;gBAClB,SAAS,EAAE,CAAC;gBACZ,QAAQ,EAAE,QAAQ;gBAClB,UAAU,EAAE,CAAC;gBACb,QAAQ,EAAE,CAAC;gBACX,GAAG,CAAC,SAAS,IAAI,EAAE,SAAS,EAAE,CAAC;gBAC/B,GAAG,CAAC,CAAA,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,GAAG,KAAI,EAAE,iBAAiB,EAAE,GAAG,aAAH,GAAG,uBAAH,GAAG,CAAE,GAAG,EAAE,CAAC;aAClC,CAAC,CAAC;QAClB,CAAC;IACF,CAAC;IAED,kBAAkB,CAAC,IAAI,CAAC;QACvB,EAAE,EAAE,OAAO;QACX,MAAM,EAAE,WAAW;KACH,CAAC,CAAC;IAEnB,OAAO,kBAAkB,CAAC;AAC3B,CAAC","sourcesContent":["import type { AudioTrack } from '../../../types/model/AudioTrack.js';\nimport type { SwitchingSet } from '../../../types/model/SwitchingSet.js';\n\nimport type { Manifest } from '../../../types/manifest/Manifest.js';\n\nimport { parseHlsManifest } from '../../../utils/hls/parseHlsManifest.js';\n\nimport { formatSegments } from './utils/formatSegments.js';\nimport { getByterange } from './utils/getByterange.js';\nimport { getCodec } from './utils/getCodec.js';\nimport { getDuration } from './utils/getDuration.js';\n\n/**\n * @internal\n *\n * This function is used to convert audio groups to switching sets.\n *\n *\n * @param mediaGroupsAudio - Any\n * @param manifestPlaylists - Array of Manifest\n * @returns Array of switchingSet\n *\n * @group CMAF\n * @alpha\n */\nexport function audioGroupsToSwitchingSets(\n\tmediaGroupsAudio: any,\n\tmanifestPlaylists: Manifest[],\n): SwitchingSet[] {\n\tconst audioSwitchingSets: SwitchingSet[] = [];\n\tconst audioTracks: AudioTrack[] = [];\n\n\tfor (const audioEncodings in mediaGroupsAudio) {\n\t\tconst encodings = mediaGroupsAudio[audioEncodings];\n\t\tfor (const audio in encodings) {\n\t\t\tconst attributes: any = encodings[audio];\n\t\t\tconst { language, uri } = attributes;\n\t\t\tconst audioParsed = parseHlsManifest(\n\t\t\t\tmanifestPlaylists.shift()?.manifest,\n\t\t\t);\n\t\t\tconst map = audioParsed?.segments[0]?.map;\n\t\t\tconst segments = formatSegments(audioParsed?.segments);\n\n\t\t\t// TODO: channels, sampleRate, bandwith and codec need to be\n\t\t\t// updated with real values. Right now we are using simple hardcoded values.\n\t\t\tconst byteRange = getByterange(map?.byterange);\n\t\t\taudioTracks.push({\n\t\t\t\tid: audio,\n\t\t\t\ttype: 'audio',\n\t\t\t\tfileName: uri,\n\t\t\t\tcodec: getCodec('audio'),\n\t\t\t\tduration: getDuration(audioParsed, segments),\n\t\t\t\tlanguage: language,\n\t\t\t\tbandwidth: 0,\n\t\t\t\tsegments: segments,\n\t\t\t\tsampleRate: 0,\n\t\t\t\tchannels: 2,\n\t\t\t\t...(byteRange && { byteRange }),\n\t\t\t\t...(map?.uri && { urlInitialization: map?.uri }),\n\t\t\t} as AudioTrack);\n\t\t}\n\t}\n\n\taudioSwitchingSets.push({\n\t\tid: 'audio',\n\t\ttracks: audioTracks,\n\t} as SwitchingSet);\n\n\treturn audioSwitchingSets;\n}\n"]}