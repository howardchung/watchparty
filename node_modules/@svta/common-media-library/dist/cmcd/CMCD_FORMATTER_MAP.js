import { SfItem } from '../structuredfield/SfItem.js';
import { urlToRelativePath } from '../utils/urlToRelativePath.js';
const toRounded = (value) => Math.round(value);
const toUrlSafe = (value, options) => {
    if (Array.isArray(value)) {
        return value.map(item => toUrlSafe(item, options));
    }
    if (value instanceof SfItem && typeof value.value === 'string') {
        return new SfItem(toUrlSafe(value.value, options), value.params);
    }
    else {
        if (options.baseUrl) {
            value = urlToRelativePath(value, options.baseUrl);
        }
        return options.version === 1 ? encodeURIComponent(value) : value;
    }
};
const toHundred = (value) => toRounded(value / 100) * 100;
const nor = (value, options) => {
    let norValue = value;
    if (options.version >= 2) {
        if (value instanceof SfItem && typeof value.value === 'string') {
            norValue = new SfItem([value]);
        }
        else if (typeof value === 'string') {
            norValue = [value];
        }
    }
    return toUrlSafe(norValue, options);
};
/**
 * The default formatters for CMCD values.
 *
 * @group CMCD
 *
 * @beta
 */
export const CMCD_FORMATTER_MAP = {
    /**
     * Bitrate (kbps) rounded integer
     */
    br: toRounded,
    /**
     * Duration (milliseconds) rounded integer
     */
    d: toRounded,
    /**
     * Buffer Length (milliseconds) rounded nearest 100ms
     */
    bl: toHundred,
    /**
     * Deadline (milliseconds) rounded nearest 100ms
     */
    dl: toHundred,
    /**
     * Measured Throughput (kbps) rounded nearest 100kbps
     */
    mtp: toHundred,
    /**
     * Next Object Request URL encoded
     */
    nor,
    /**
     * Requested maximum throughput (kbps) rounded nearest 100kbps
     */
    rtp: toHundred,
    /**
     * Top Bitrate (kbps) rounded integer
     */
    tb: toRounded,
};
//# sourceMappingURL=CMCD_FORMATTER_MAP.js.map