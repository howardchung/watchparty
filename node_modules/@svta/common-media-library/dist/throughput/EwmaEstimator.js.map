{"version":3,"file":"EwmaEstimator.js","sourceRoot":"","sources":["../../src/throughput/EwmaEstimator.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,eAAe,EAAE,MAAM,6BAA6B,CAAC;AAC9D,OAAO,EAAE,IAAI,EAAE,MAAM,WAAW,CAAC;AAIjC;;;;;;GAMG;AACH,MAAM,OAAO,aAAa;IAIzB,YAAmB,OAA6B;QAC/C,IAAI,CAAC,QAAQ,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;QAC/C,IAAI,CAAC,QAAQ,GAAG,IAAI,IAAI,CAAC,OAAO,CAAC,YAAY,CAAC,CAAC;IAChD,CAAC;IAEM,MAAM,CAAC,MAAsB;QACnC,cAAc;QACd,kFAAkF;QAClF,gBAAgB;QAChB,uEAAuE;QACvE,eAAe;QACf,wGAAwG;QACxG,MAAM,eAAe,GAAG,MAAM,CAAC,QAAQ,GAAG,IAAI,CAAC;QAC/C,MAAM,YAAY,GAAG,eAAe,CAAC,MAAM,CAAC,CAAC;QAE7C,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;QACpD,IAAI,CAAC,QAAQ,CAAC,MAAM,CAAC,eAAe,EAAE,YAAY,CAAC,CAAC;IACrD,CAAC;IAEM,WAAW;QACjB,cAAc;QACd,6EAA6E;QAC7E,kDAAkD;QAClD,6DAA6D;QAC7D,gBAAgB;QAChB,+CAA+C;QAC/C,wCAAwC;QACxC,eAAe;QACf,2EAA2E;QAC3E,mEAAmE;QACnE,OAAO,IAAI,CAAC,GAAG,CAAC,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,EAAE,IAAI,CAAC,QAAQ,CAAC,WAAW,EAAE,CAAC,CAAC;IAC3E,CAAC;IAEM,WAAW;QACjB,0DAA0D;QAC1D,yDAAyD;QAEzD,OAAO,IAAI,CAAC;IACb,CAAC;CACD","sourcesContent":["import type { ResourceTiming } from '../request/ResourceTiming.js';\nimport { getBandwidthBps } from '../utils/getBandwidthBps.js';\nimport { Ewma } from './Ewma.js';\nimport type { EwmaEstimatorOptions } from './EwmaEstimatorOptions.js';\nimport type { ThroughputEstimator } from './ThroughputEstimator.js';\n\n/**\n * Exponential Weighted Moving Average (EWMA) throughput estimator based on 2 half-lives\n *\n * @group Throughput\n *\n * @beta\n */\nexport class EwmaEstimator implements ThroughputEstimator {\n\tprivate fastEwma: Ewma;\n\tprivate slowEwma: Ewma;\n\n\tpublic constructor(options: EwmaEstimatorOptions) {\n\t\tthis.slowEwma = new Ewma(options.slowHalfLife);\n\t\tthis.fastEwma = new Ewma(options.fastHalfLife);\n\t}\n\n\tpublic sample(sample: ResourceTiming): void {\n\t\t// TODO: shaka\n\t\t// 1. If `sample.encodedBodySize` is less than `this.minBytes_`, don't do anything\n\t\t// TODO: dash.js\n\t\t// 1. If `sample.encodedBodySize` is NaN or Infinity, don't do anything\n\t\t// TODO: hls.js\n\t\t// 1. If `durationSeconds` is less than `this.minDelayMs_`, make it `this.minDelayMs_` (default is 50ms)\n\t\tconst durationSeconds = sample.duration / 1000;\n\t\tconst bandwidthBps = getBandwidthBps(sample);\n\n\t\tthis.slowEwma.sample(durationSeconds, bandwidthBps);\n\t\tthis.fastEwma.sample(durationSeconds, bandwidthBps);\n\t}\n\n\tpublic getEstimate(): number {\n\t\t// TODO: shaka\n\t\t// 1. Returns `defaultEstimate` for this.totalBytes < `options.minTotalBytes`\n\t\t// 1.1. Returns `options.defaultBandwidthEstimate`\n\t\t// 1.2. or `navigator.connection.downlink * 1e6` if available\n\t\t// TODO: dash.js\n\t\t// 1. Returns `NaN` for this.totalDuration <= 0\n\t\t// 2. `Math.max` for latency calculation\n\t\t// TODO: hls.js\n\t\t// 1. Returns `defaultEstimate` for this.totalDuration < `this.minDuration`\n\t\t// 1.1. Returns `config.abrEwmaDefaultEstimate` (default: 500 kbps)\n\t\treturn Math.min(this.fastEwma.getEstimate(), this.slowEwma.getEstimate());\n\t}\n\n\tpublic canEstimate(): boolean {\n\t\t// TODO: shaka, `this.totalBytes >= options.minTotalBytes`\n\t\t// TODO: hls.js, `this.totalDuration >= this.minDuration`\n\n\t\treturn true;\n\t}\n}\n"]}