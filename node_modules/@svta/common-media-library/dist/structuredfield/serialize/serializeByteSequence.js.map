{"version":3,"file":"serializeByteSequence.js","sourceRoot":"","sources":["../../../src/structuredfield/serialize/serializeByteSequence.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,6BAA6B,CAAC;AAC3D,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAC1C,OAAO,EAAE,cAAc,EAAE,MAAM,qBAAqB,CAAC;AAErD,sCAAsC;AACtC,EAAE;AACF,wEAAwE;AACxE,iCAAiC;AACjC,EAAE;AACF,qEAAqE;AACrE,EAAE;AACF,qCAAqC;AACrC,EAAE;AACF,4BAA4B;AAC5B,EAAE;AACF,8DAA8D;AAC9D,sEAAsE;AACtE,EAAE;AACF,4BAA4B;AAC5B,EAAE;AACF,qBAAqB;AACrB,EAAE;AACF,wEAAwE;AACxE,eAAe;AACf,EAAE;AACF,kEAAkE;AAClE,oEAAoE;AACpE,8BAA8B;AAC9B,MAAM,UAAU,qBAAqB,CAAC,KAAiB;IACtD,IAAI,WAAW,CAAC,MAAM,CAAC,KAAK,CAAC,KAAK,KAAK,EAAE,CAAC;QACzC,MAAM,cAAc,CAAC,KAAK,EAAE,KAAK,CAAC,CAAC;IACpC,CAAC;IACD,OAAO,IAAI,YAAY,CAAC,KAAK,CAAC,GAAG,CAAC;AACnC,CAAC","sourcesContent":["import { base64encode } from '../../utils/base64encode.js';\nimport { BYTES } from '../utils/BYTES.js';\nimport { serializeError } from './serializeError.js';\n\n// 4.1.8.  Serializing a Byte Sequence\n//\n// Given a Byte Sequence as input_bytes, return an ASCII string suitable\n// for use in a HTTP field value.\n//\n// 1.  If input_bytes is not a sequence of bytes, fail serialization.\n//\n// 2.  Let output be an empty string.\n//\n// 3.  Append \":\" to output.\n//\n// 4.  Append the result of base64-encoding input_bytes as per\n//     [RFC4648], Section 4, taking account of the requirements below.\n//\n// 5.  Append \":\" to output.\n//\n// 6.  Return output.\n//\n// The encoded data is required to be padded with \"=\", as per [RFC4648],\n// Section 3.2.\n//\n// Likewise, encoded data SHOULD have pad bits set to zero, as per\n// [RFC4648], Section 3.5, unless it is not possible to do so due to\n// implementation constraints.\nexport function serializeByteSequence(value: Uint8Array) {\n\tif (ArrayBuffer.isView(value) === false) {\n\t\tthrow serializeError(value, BYTES);\n\t}\n\treturn `:${base64encode(value)}:`;\n}\n"]}