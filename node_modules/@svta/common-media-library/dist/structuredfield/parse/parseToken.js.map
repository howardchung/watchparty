{"version":3,"file":"parseToken.js","sourceRoot":"","sources":["../../../src/structuredfield/parse/parseToken.ts"],"names":[],"mappings":"AACA,OAAO,EAAE,OAAO,EAAE,MAAM,eAAe,CAAC;AACxC,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAE1C,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,0BAA0B;AAC1B,EAAE;AACF,sEAAsE;AACtE,0CAA0C;AAC1C,EAAE;AACF,uEAAuE;AACvE,eAAe;AACf,EAAE;AACF,4CAA4C;AAC5C,EAAE;AACF,uCAAuC;AACvC,EAAE;AACF,sEAAsE;AACtE,wCAAwC;AACxC,EAAE;AACF,qEAAqE;AACrE,wBAAwB;AACxB,EAAE;AACF,wCAAwC;AACxC,EAAE;AACF,4BAA4B;AAC5B,MAAM,UAAU,UAAU,CAAC,GAAW,EAAE,OAAyB;IAChE,IAAI,aAAa,CAAC,IAAI,CAAC,GAAG,CAAC,CAAC,CAAC,CAAC,KAAK,KAAK,EAAE,CAAC;QAC1C,MAAM,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED,MAAM,EAAE,GAAG,6BAA6B,CAAC;IACzC,MAAM,KAAK,GAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAS,CAAC,CAAC,CAAC,CAAC;IACvC,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;IAElC,OAAO,WAAW,CACjB,CAAA,OAAO,aAAP,OAAO,uBAAP,OAAO,CAAE,SAAS,MAAK,KAAK,CAAC,CAAC,CAAC,IAAI,OAAO,CAAC,KAAK,CAAC,CAAC,CAAC,CAAC,MAAM,CAAC,GAAG,CAAC,KAAK,CAAC,EACrE,GAAG,CACH,CAAC;AACH,CAAC","sourcesContent":["import type { SfDecodeOptions } from '../SfDecodeOptions.js';\nimport { SfToken } from '../SfToken.js';\nimport { TOKEN } from '../utils/TOKEN.js';\nimport type { ParsedValue } from './ParsedValue.js';\nimport { parsedValue } from './ParsedValue.js';\nimport { parseError } from './parseError.js';\n\n// 4.2.6.  Parsing a Token\n//\n// Given an ASCII string as input_string, return a Token. input_string\n// is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not ALPHA or \"*\", fail\n//     parsing.\n//\n// 2.  Let output_string be an empty string.\n//\n// 3.  While input_string is not empty:\n//\n//     1.  If the first character of input_string is not in tchar, \":\"\n//         or \"/\", return output_string.\n//\n//     2.  Let char be the result of consuming the first character of\n//         input_string.\n//\n//     3.  Append char to output_string.\n//\n// 4.  Return output_string.\nexport function parseToken(src: string, options?: SfDecodeOptions): ParsedValue<symbol | SfToken> {\n\tif (/^[a-zA-Z*]$/.test(src[0]) === false) {\n\t\tthrow parseError(src, TOKEN);\n\t}\n\n\tconst re = /^([!#$%&'*+\\-.^_`|~\\w:/]+)/g;\n\tconst value = (re.exec(src) as any)[1];\n\tsrc = src.substring(re.lastIndex);\n\n\treturn parsedValue(\n\t\toptions?.useSymbol === false ? new SfToken(value) : Symbol.for(value),\n\t\tsrc,\n\t);\n}\n"]}