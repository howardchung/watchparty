{"version":3,"file":"parseIntegerOrDecimal.js","sourceRoot":"","sources":["../../../src/structuredfield/parse/parseIntegerOrDecimal.ts"],"names":[],"mappings":"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","sourcesContent":["import { INTEGER_DECIMAL } from '../utils/INTEGER_DECIMAL.js';\nimport { isInvalidInt } from '../utils/isInvalidInt.js';\nimport type { ParsedValue } from './ParsedValue.js';\nimport { parsedValue } from './ParsedValue.js';\nimport { parseError } from './parseError.js';\n\n// 4.2.4.  Parsing an Integer or Decimal\n//\n// Given an ASCII string as input_string, return an Integer or Decimal.\n// input_string is modified to remove the parsed value.\n//\n// NOTE: This algorithm parses both Integers (Section 3.3.1) and\n// Decimals (Section 3.3.2), and returns the corresponding structure.\n//\n// 1.   Let type be \"integer\".\n//\n// 2.   Let sign be 1.\n//\n// 3.   Let input_number be an empty string.\n//\n// 4.   If the first character of input_string is \"-\", consume it and\n//      set sign to -1.\n//\n// 5.   If input_string is empty, there is an empty integer; fail\n//      parsing.\n//\n// 6.   If the first character of input_string is not a DIGIT, fail\n//      parsing.\n//\n// 7.   While input_string is not empty:\n//\n//      1.  Let char be the result of consuming the first character of\n//          input_string.\n//\n//      2.  If char is a DIGIT, append it to input_number.\n//\n//      3.  Else, if type is \"integer\" and char is \".\":\n//\n//          1.  If input_number contains more than 12 characters, fail\n//              parsing.\n//\n//          2.  Otherwise, append char to input_number and set type to\n//              \"decimal\".\n//\n//      4.  Otherwise, prepend char to input_string, and exit the loop.\n//\n//      5.  If type is \"integer\" and input_number contains more than 15\n//          characters, fail parsing.\n//\n//      6.  If type is \"decimal\" and input_number contains more than 16\n//          characters, fail parsing.\n//\n// 8.   If type is \"integer\":\n//\n//      1.  Parse input_number as an integer and let output_number be\n//          the product of the result and sign.\n//\n//      2.  If output_number is outside the range -999,999,999,999,999\n//          to 999,999,999,999,999 inclusive, fail parsing.\n//\n// 9.   Otherwise:\n//\n//      1.  If the final character of input_number is \".\", fail parsing.\n//\n//      2.  If the number of characters after \".\" in input_number is\n//          greater than three, fail parsing.\n//\n//      3.  Parse input_number as a decimal number and let output_number\n//          be the product of the result and sign.\n//\n// 10.  Return output_number.\nexport function parseIntegerOrDecimal(src: string): ParsedValue<number> {\n\tconst orig = src;\n\tlet sign = 1;\n\tlet num = '';\n\tlet value;\n\tconst i = 0;\n\tconst error = parseError(orig, INTEGER_DECIMAL);\n\n\tif (src[i] === '-') {\n\t\tsign = -1;\n\t\tsrc = src.substring(1);\n\t}\n\n\tif (src.length <= 0) {\n\t\tthrow error;\n\t}\n\n\tconst re_integer = /^(\\d+)?/g;\n\tconst result_integer = re_integer.exec(src) as any;\n\tif (result_integer[0].length === 0) {\n\t\tthrow error;\n\t}\n\tnum += result_integer[1];\n\tsrc = src.substring(re_integer.lastIndex);\n\n\tif (src[0] === '.') {\n\t\t// decimal\n\t\tif (num.length > 12) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tconst re_decimal = /^(\\.\\d+)?/g;\n\t\tconst result_decimal = re_decimal.exec(src) as any;\n\t\tsrc = src.substring(re_decimal.lastIndex);\n\t\t// 9.2.  If the number of characters after \".\" in input_number is greater than three, fail parsing.\n\t\tif (result_decimal[0].length === 0 || result_decimal[1].length > 4) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tnum += result_decimal[1];\n\t\t// 7.6.  If type is \"decimal\" and input_number contains more than 16 characters, fail parsing.\n\t\tif (num.length > 16) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tvalue = parseFloat(num) * sign;\n\t}\n\telse {\n\t\t// integer\n\t\t// 7.5.  If type is \"integer\" and input_number contains more than 15 characters, fail parsing.\n\t\tif (num.length > 15) {\n\t\t\tthrow error;\n\t\t}\n\n\t\tvalue = parseInt(num) * sign;\n\t\tif (isInvalidInt(value)) {\n\t\t\tthrow parseError(num, INTEGER_DECIMAL);\n\t\t}\n\t}\n\n\treturn parsedValue(value, src);\n}\n"]}