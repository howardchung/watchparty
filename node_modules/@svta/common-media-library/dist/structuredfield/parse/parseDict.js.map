{"version":3,"file":"parseDict.js","sourceRoot":"","sources":["../../../src/structuredfield/parse/parseDict.ts"],"names":[],"mappings":"AAGA,OAAO,EAAE,MAAM,EAAE,MAAM,cAAc,CAAC;AACtC,OAAO,EAAE,IAAI,EAAE,MAAM,kBAAkB,CAAC;AAExC,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAC7C,OAAO,EAAE,oBAAoB,EAAE,MAAM,2BAA2B,CAAC;AACjE,OAAO,EAAE,QAAQ,EAAE,MAAM,eAAe,CAAC;AACzC,OAAO,EAAE,eAAe,EAAE,MAAM,sBAAsB,CAAC;AAEvD,+BAA+B;AAC/B,EAAE;AACF,qEAAqE;AACrE,sEAAsE;AACtE,uCAAuC;AACvC,EAAE;AACF,+CAA+C;AAC/C,EAAE;AACF,uCAAuC;AACvC,EAAE;AACF,8DAA8D;AAC9D,+CAA+C;AAC/C,EAAE;AACF,yDAAyD;AACzD,EAAE;AACF,2DAA2D;AAC3D,EAAE;AACF,qEAAqE;AACrE,8DAA8D;AAC9D,EAAE;AACF,qBAAqB;AACrB,EAAE;AACF,yCAAyC;AACzC,EAAE;AACF,8DAA8D;AAC9D,4DAA4D;AAC5D,EAAE;AACF,2DAA2D;AAC3D,EAAE;AACF,iEAAiE;AACjE,iEAAiE;AACjE,yDAAyD;AACzD,EAAE;AACF,gEAAgE;AAChE,EAAE;AACF,uDAAuD;AACvD,EAAE;AACF,oEAAoE;AACpE,6BAA6B;AAC7B,EAAE;AACF,gEAAgE;AAChE,EAAE;AACF,oEAAoE;AACpE,mBAAmB;AACnB,EAAE;AACF,qEAAqE;AACrE,cAAc;AACd,EAAE;AACF,qEAAqE;AACrE,oDAAoD;AACpD,MAAM,UAAU,SAAS,CAAC,GAAW,EAAE,OAAyB;IAC/D,MAAM,KAAK,GAAiB,EAAE,CAAC;IAE/B,OAAO,GAAG,CAAC,MAAM,GAAG,CAAC,EAAE,CAAC;QACvB,IAAI,MAA4B,CAAC;QACjC,MAAM,SAAS,GAAG,QAAQ,CAAC,GAAG,CAAC,CAAC;QAChC,MAAM,GAAG,GAAG,SAAS,CAAC,KAAK,CAAC;QAC5B,GAAG,GAAG,SAAS,CAAC,GAAG,CAAC;QAEpB,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACpB,MAAM,qBAAqB,GAAG,oBAAoB,CAAC,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,EAAE,OAAO,CAAC,CAAC;YAC9E,MAAM,GAAG,qBAAqB,CAAC,KAAK,CAAC;YACrC,GAAG,GAAG,qBAAqB,CAAC,GAAG,CAAC;QACjC,CAAC;aACI,CAAC;YACL,MAAM,gBAAgB,GAAG,eAAe,CAAC,GAAG,EAAE,OAAO,CAAC,CAAC;YACvD,MAAM,GAAG,IAAI,MAAM,CAAC,IAAI,EAAE,gBAAgB,CAAC,KAAK,CAAC,CAAC;YAClD,GAAG,GAAG,gBAAgB,CAAC,GAAG,CAAC;QAC5B,CAAC;QAED,KAAK,CAAC,GAAG,CAAC,GAAG,MAAM,CAAC;QAEpB,GAAG,GAAG,GAAG,CAAC,IAAI,EAAE,CAAC;QACjB,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,EAAE,CAAC;YACtB,OAAO,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;QAChC,CAAC;QAED,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACpB,MAAM,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7B,CAAC;QAED,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC,IAAI,EAAE,CAAC;QAC9B,IAAI,GAAG,CAAC,MAAM,KAAK,CAAC,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;YACxC,MAAM,UAAU,CAAC,GAAG,EAAE,IAAI,CAAC,CAAC;QAC7B,CAAC;IACF,CAAC;IAED,OAAO,WAAW,CAAC,KAAK,EAAE,GAAG,CAAC,CAAC;AAChC,CAAC","sourcesContent":["import type { SfDecodeOptions } from '../SfDecodeOptions.js';\nimport type { SfDictionary } from '../SfDictionary.js';\nimport type { SfInnerList } from '../SfInnerList.js';\nimport { SfItem } from '../SfItem.js';\nimport { DICT } from '../utils/DICT.js';\nimport type { ParsedValue } from './ParsedValue.js';\nimport { parsedValue } from './ParsedValue.js';\nimport { parseError } from './parseError.js';\nimport { parseItemOrInnerList } from './parseItemOrInnerList.js';\nimport { parseKey } from './parseKey.js';\nimport { parseParameters } from './parseParameters.js';\n\n// 4.2.2.  Parsing a Dictionary\n//\n// Given an ASCII string as input_string, return an ordered map whose\n// values are (item_or_inner_list, parameters) tuples. input_string is\n// modified to remove the parsed value.\n//\n// 1.  Let dictionary be an empty, ordered map.\n//\n// 2.  While input_string is not empty:\n//\n//     1.  Let this_key be the result of running Parsing a Key\n//         (Section 4.2.3.3) with input_string.\n//\n//     2.  If the first character of input_string is \"=\":\n//\n//         1.  Consume the first character of input_string.\n//\n//         2.  Let member be the result of running Parsing an Item or\n//             Inner List (Section 4.2.1.1) with input_string.\n//\n//     3.  Otherwise:\n//\n//         1.  Let value be Boolean true.\n//\n//         2.  Let parameters be the result of running Parsing\n//             Parameters Section 4.2.3.2 with input_string.\n//\n//         3.  Let member be the tuple (value, parameters).\n//\n//     4.  Add name this_key with value member to dictionary.  If\n//         dictionary already contains a name this_key (comparing\n//         character-for-character), overwrite its value.\n//\n//     5.  Discard any leading OWS characters from input_string.\n//\n//     6.  If input_string is empty, return dictionary.\n//\n//     7.  Consume the first character of input_string; if it is not\n//         \",\", fail parsing.\n//\n//     8.  Discard any leading OWS characters from input_string.\n//\n//     9.  If input_string is empty, there is a trailing comma; fail\n//         parsing.\n//\n// 3.  No structured data has been found; return dictionary (which is\n//     empty).\n//\n// Note that when duplicate Dictionary keys are encountered, this has\n// the effect of ignoring all but the last instance.\nexport function parseDict(src: string, options?: SfDecodeOptions): ParsedValue<SfDictionary> {\n\tconst value: SfDictionary = {};\n\n\twhile (src.length > 0) {\n\t\tlet member: SfItem | SfInnerList;\n\t\tconst parsedKey = parseKey(src);\n\t\tconst key = parsedKey.value;\n\t\tsrc = parsedKey.src;\n\n\t\tif (src[0] === '=') {\n\t\t\tconst parsedItemOrInnerList = parseItemOrInnerList(src.substring(1), options);\n\t\t\tmember = parsedItemOrInnerList.value;\n\t\t\tsrc = parsedItemOrInnerList.src;\n\t\t}\n\t\telse {\n\t\t\tconst parsedParameters = parseParameters(src, options);\n\t\t\tmember = new SfItem(true, parsedParameters.value);\n\t\t\tsrc = parsedParameters.src;\n\t\t}\n\n\t\tvalue[key] = member;\n\n\t\tsrc = src.trim();\n\t\tif (src.length === 0) {\n\t\t\treturn parsedValue(value, src);\n\t\t}\n\n\t\tif (src[0] !== ',') {\n\t\t\tthrow parseError(src, DICT);\n\t\t}\n\n\t\tsrc = src.substring(1).trim();\n\t\tif (src.length === 0 || src[0] === ',') {\n\t\t\tthrow parseError(src, DICT);\n\t\t}\n\t}\n\n\treturn parsedValue(value, src);\n}\n"]}