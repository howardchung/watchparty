{"version":3,"file":"parseByteSequence.js","sourceRoot":"","sources":["../../../src/structuredfield/parse/parseByteSequence.ts"],"names":[],"mappings":"AAAA,OAAO,EAAE,YAAY,EAAE,MAAM,6BAA6B,CAAC;AAC3D,OAAO,EAAE,KAAK,EAAE,MAAM,mBAAmB,CAAC;AAE1C,OAAO,EAAE,WAAW,EAAE,MAAM,kBAAkB,CAAC;AAC/C,OAAO,EAAE,UAAU,EAAE,MAAM,iBAAiB,CAAC;AAE7C,kCAAkC;AAClC,EAAE;AACF,iEAAiE;AACjE,uDAAuD;AACvD,EAAE;AACF,uEAAuE;AACvE,EAAE;AACF,mDAAmD;AACnD,EAAE;AACF,sEAAsE;AACtE,oBAAoB;AACpB,EAAE;AACF,4DAA4D;AAC5D,qEAAqE;AACrE,qBAAqB;AACrB,EAAE;AACF,kEAAkE;AAClE,EAAE;AACF,wEAAwE;AACxE,sCAAsC;AACtC,EAAE;AACF,qEAAqE;AACrE,+DAA+D;AAC/D,oDAAoD;AACpD,EAAE;AACF,6BAA6B;AAC7B,EAAE;AACF,mEAAmE;AACnE,+DAA+D;AAC/D,gEAAgE;AAChE,sDAAsD;AACtD,EAAE;AACF,mEAAmE;AACnE,wEAAwE;AACxE,qEAAqE;AACrE,sCAAsC;AACtC,EAAE;AACF,mEAAmE;AACnE,kEAAkE;AAClE,kEAAkE;AAClE,MAAM,UAAU,iBAAiB,CAAC,GAAW;IAC5C,IAAI,GAAG,CAAC,CAAC,CAAC,KAAK,GAAG,EAAE,CAAC;QACpB,MAAM,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,CAAC,CAAC,CAAC;IACvB,IAAI,GAAG,CAAC,QAAQ,CAAC,GAAG,CAAC,KAAK,KAAK,EAAE,CAAC;QACjC,MAAM,UAAU,CAAC,GAAG,EAAE,KAAK,CAAC,CAAC;IAC9B,CAAC;IAED,MAAM,EAAE,GAAG,YAAY,CAAC;IACxB,MAAM,WAAW,GAAI,EAAE,CAAC,IAAI,CAAC,GAAG,CAAS,CAAC,CAAC,CAAC,CAAC;IAC7C,GAAG,GAAG,GAAG,CAAC,SAAS,CAAC,EAAE,CAAC,SAAS,CAAC,CAAC;IAElC,qCAAqC;IACrC,OAAO,WAAW,CACjB,YAAY,CAAC,WAAW,CAAC,EACzB,GAAG,CACH,CAAC;AACH,CAAC","sourcesContent":["import { decodeBase64 } from '../../utils/decodeBase64.js';\nimport { BYTES } from '../utils/BYTES.js';\nimport type { ParsedValue } from './ParsedValue.js';\nimport { parsedValue } from './ParsedValue.js';\nimport { parseError } from './parseError.js';\n\n// 4.2.7.  Parsing a Byte Sequence\n//\n// Given an ASCII string as input_string, return a Byte Sequence.\n// input_string is modified to remove the parsed value.\n//\n// 1.  If the first character of input_string is not \":\", fail parsing.\n//\n// 2.  Discard the first character of input_string.\n//\n// 3.  If there is not a \":\" character before the end of input_string,\n//     fail parsing.\n//\n// 4.  Let b64_content be the result of consuming content of\n//     input_string up to but not including the first instance of the\n//     character \":\".\n//\n// 5.  Consume the \":\" character at the beginning of input_string.\n//\n// 6.  If b64_content contains a character not included in ALPHA, DIGIT,\n//     \"+\", \"/\" and \"=\", fail parsing.\n//\n// 7.  Let binary_content be the result of Base 64 Decoding [RFC4648]\n//     b64_content, synthesizing padding if necessary (note the\n//     requirements about recipient behavior below).\n//\n// 8.  Return binary_content.\n//\n// Because some implementations of base64 do not allow rejection of\n// encoded data that is not properly \"=\" padded (see [RFC4648],\n// Section 3.2), parsers SHOULD NOT fail when \"=\" padding is not\n// present, unless they cannot be configured to do so.\n//\n// Because some implementations of base64 do not allow rejection of\n// encoded data that has non-zero pad bits (see [RFC4648], Section 3.5),\n// parsers SHOULD NOT fail when non-zero pad bits are present, unless\n// they cannot be configured to do so.\n//\n// This specification does not relax the requirements in [RFC4648],\n// Section 3.1 and 3.3; therefore, parsers MUST fail on characters\n// outside the base64 alphabet, and on line feeds in encoded data.\nexport function parseByteSequence(src: string): ParsedValue<Uint8Array> {\n\tif (src[0] !== ':') {\n\t\tthrow parseError(src, BYTES);\n\t}\n\n\tsrc = src.substring(1);\n\tif (src.includes(':') === false) {\n\t\tthrow parseError(src, BYTES);\n\t}\n\n\tconst re = /(^.*?)(:)/g;\n\tconst b64_content = (re.exec(src) as any)[1];\n\tsrc = src.substring(re.lastIndex);\n\n\t// pass b64_content char check step 6\n\treturn parsedValue(\n\t\tdecodeBase64(b64_content),\n\t\tsrc,\n\t);\n}\n"]}