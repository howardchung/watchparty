import { WebVttParser } from './WebVttParser.js';
import { WebVttResultType } from './WebVttResultType.js';
/**
 * WebVTT transform stream transformer.
 *
 * @group WebVTT
 *
 * @beta
 */
export class WebVttTransformer {
    /**
     * Creates a new WebVTT transformer.
     */
    constructor() {
        this.results = [];
        this.parser = new WebVttParser();
        this.parser.oncue = cue => this.results.push({ type: WebVttResultType.CUE, data: cue });
        this.parser.onregion = region => this.results.push({ type: WebVttResultType.REGION, data: region });
        this.parser.onstyle = style => this.results.push({ type: WebVttResultType.STYLE, data: style });
        this.parser.ontimestampmap = timestampmap => this.results.push({ type: WebVttResultType.TIMESTAMP_MAP, data: timestampmap });
        this.parser.onparsingerror = error => this.results.push({ type: WebVttResultType.ERROR, data: error });
    }
    enqueueResults(controller) {
        // TODO: Should parse errors throw?
        for (const result of this.results) {
            controller.enqueue(result);
        }
        this.results = [];
    }
    /**
     * Transforms a chunk of WebVTT data.
     *
     * @param chunk - The chunk of WebVTT data to transform.
     * @param controller - The controller to enqueue the results to.
     */
    transform(chunk, controller) {
        try {
            this.parser.parse(chunk);
            this.enqueueResults(controller);
        }
        catch (error) {
            controller.error(error);
        }
    }
    /**
     * Flushes the transformer.
     *
     * @param controller - The controller to enqueue the results to.
     */
    flush(controller) {
        try {
            this.parser.flush();
            this.enqueueResults(controller);
        }
        catch (error) {
            controller.error(error);
        }
    }
}
//# sourceMappingURL=WebVttTransformer.js.map