{"version":3,"file":"CmsdStatic.js","sourceRoot":"","sources":["../../src/cmsd/CmsdStatic.ts"],"names":[],"mappings":"","sourcesContent":["import type { CmsdCustomKey } from './CmsdCustomKey.js';\nimport type { CmsdObjectType } from './CmsdObjectType.js';\nimport type { CmsdStreamType } from './CmsdStreamType.js';\nimport type { CmsdStreamingFormat } from './CmsdStreamingFormat.js';\nimport type { CmsdValue } from './CmsdValue.js';\n\n/**\n * Common Media Server Data (CMSD) static response header fields.\n *\n * @see {@link https://cdn.cta.tech/cta/media/media/resources/standards/pdfs/cta-5006-final.pdf|CMSD Spec}\n *\n * @group CMSD\n *\n * @beta\n */\nexport type CmsdStatic = {\n\n\t/**\n\t * Custom key names may be used, but they MUST carry a hyphenated prefix to ensure that there will not be a namespace collision\n\t * with future revisions to this specification. Clients SHOULD use a reverse-DNS syntax when defining their own prefix.\n\t */\n\t[index: CmsdCustomKey]: CmsdValue;\n\n\t/**\n\t * Availability time\n\t *\n\t * The wallclock time at which the first byte of this object became available at the origin for successful request. The time is\n\t * expressed as integer milliseconds since the Unix Epoch, i.e., the number of milliseconds that have elapsed since January 1,\n\t * 1970 (midnight UTC/GMT), not counting leap seconds (in ISO 8601: 1970- 01-01T00:00:000Z).\n\t *\n\t * Integer Milliseconds\n\t */\n\tat?: number;\n\n\t/**\n\t * Encoded bitrate\n\t *\n\t * The encoded bitrate of the audio or video object being requested. If the instantaneous bitrate varies over the duration of the\n\t * object, the average value over the duration of the object SHOULD be communicated. This key should only accompany objects that\n\t * have an implicit bitrate.\n\t *\n\t * Integer kbps\n\t */\n\tbr?: number;\n\n\t/**\n\t * Object duration\n\t *\n\t * The playback duration in milliseconds of the object being requested. If a partial segment is being requested, then this value\n\t * MUST indicate the playback duration of that part and not that of its parent segment. This value can be an approximation of the\n\t * estimated duration if the explicit value is not known.\n\t *\n\t * Integer milliseconds\n\t */\n\td?: number;\n\n\t/**\n\t * Held time\n\t *\n\t * The number of milliseconds that this response was held back by an origin before returning. This is applicable to blocking responses\n\t * under LL-HLS [HLSbis].\n\t *\n\t * Integer Milliseconds\n\t */\n\tht?: number;\n\n\t/**\n\t * Intermediary identifier\n\t *\n\t * An identifier for the processing server. The value SHOULD identify both the organization and the intermediary that is writing the key.\n\t * Identifiers SHOULD be as concise as possible to reduce log file and transferred size, while still remaining unique.\n\t *\n\t * String\n\t */\n\tn?: string;\n\n\t/**\n\t * Next object request\n\t *\n\t * Relative path of the next object to be requested. This can be used to trigger pre-fetching by the CDN. This MUST be a path relative to the current\n\t * request. This string MUST be URLEncoded. The client SHOULD NOT depend upon any pre-fetch action being taken - it is merely a request for such a\n\t * pre-fetch to take place.\n\t *\n\t * String\n\t */\n\tnor?: string;\n\n\t/**\n\t * Next range request\n\t *\n\t * If the next request will be a partial object request, then this string denotes the byte range to be requested. If the ‘nor’ field is not set, then the\n\t * object is assumed to match the object currently being requested. The client SHOULD NOT depend upon any pre-fetch action being taken – it is merely a\n\t * request for such a pre-fetch to take place. Formatting is similar to the HTTP Range header, except that the unit MUST be ‘byte’, the ‘Range:’ prefix is\n\t * NOT required and specifying multiple ranges is NOT allowed. Valid combinations are:\n\t *\n\t * - `\"\\<range-start\\>-\"`\n\t * - `\"\\<range-start\\>-\\<range-end\\>\"`\n\t * - `\"-\\<suffix-length\\>\"`\n\t *\n\t * String\n\t */\n\tnrr?: string;\n\n\t/**\n\t * Object type\n\t *\n\t * The media type of the current object being requested:\n\t * - `m` = text file, such as a manifest or playlist\n\t * - `a` = audio only\n\t * - `v` = video only\n\t * - `av` = muxed audio and video\n\t * - `i` = init segment\n\t * - `c` = caption or subtitle\n\t * - `tt` = ISOBMFF timed text track\n\t * - `k` = cryptographic key, license or certificate.\n\t * - `o` = other\n\t *\n\t * If the object type being requested is unknown, then this key MUST NOT be used.\n\t *\n\t * Token\n\t */\n\tot?: CmsdObjectType;\n\n\t/**\n\t * Streaming format\n\t *\n\t * The streaming format that defines the current request.\n\t *\n\t * - `d` = MPEG DASH\n\t * - `h` = HTTP Live Streaming (HLS)\n\t * - `s` = Smooth Streaming\n\t * - `o` = other\n\t *\n\t * If the streaming format being requested is unknown, then this key MUST NOT be used.\n\t *\n\t * Token\n\t */\n\tsf?: CmsdStreamingFormat;\n\n\t/**\n\t * Stream type\n\t * - `v` = all segments are available – e.g., VOD\n\t * - `l` = segments become available over time – e.g., LIVE\n\t *\n\t * Token\n\t */\n\tst?: CmsdStreamType;\n\n\t/**\n\t * Startup\n\t *\n\t * Key is included without a value if the object is needed urgently due to startup, seeking or recovery after a buffer-empty event. The media SHOULD not be\n\t * rendering when this request is made. This key MUST not be sent if it is FALSE.\n\t *\n\t * Boolean\n\t */\n\tsu?: boolean;\n\n\t/**\n\t * CMSD version\n\t *\n\t * The version of this specification used for interpreting the defined key names and values. If this key is omitted, the client and server MUST\n\t * interpret the values as being defined by version 1. Client SHOULD omit this field if the version is 1.\n\t *\n\t * Integer\n\t */\n\tv?: number;\n};\n"]}